# Do NOT edit this file to change permissions
name: SimpleWarp
main: falkirks\simplewarp\SimpleWarp
version: 2.1.0
author: Falkirks
api: [1.12.0]
load: POSTWORLD
softdepend: ["FastTransfer", "SlowTransfer", "EssentialsPE"]
permissions:
 simplewarp:
  default: op
  children:
   simplewarp.command:
    default: op
    children:
     simplewarp.command.list:
      default: true
      children:
       simplewarp.command.list.xyz:
        default: op
       simplewarp.command.list.visual:
        default: op
     simplewarp.command.addwarp:
      default: op
     simplewarp.command.delwarp:
      default: op
     simplewarp.command.warp:
      default: true
      children:
        simplewarp.command.warp.other:
         default: op
     simplewarp.command.openwarp:
      default: op
     simplewarp.command.closewarp:
       default: op
   simplewarp.essentials.notice:
    default: op
    description: Recieve messages when their is warp conflict in Essentials
   simplewarp.warp:
    default: op
    description: Allows usage of all warps
<?php
namespace falkirks\simplewarp;


use falkirks\simplewarp\api\SimpleWarpAPI;
use falkirks\simplewarp\command\AddWarpCommand;
use falkirks\simplewarp\command\CloseWarpCommand;
use falkirks\simplewarp\command\DelWarpCommand;
use falkirks\simplewarp\command\essentials\EssentialsDelWarpCommand;
use falkirks\simplewarp\command\essentials\EssentialsWarpCommand;
use falkirks\simplewarp\command\ListWarpsCommand;
use falkirks\simplewarp\command\OpenWarpCommand;
use falkirks\simplewarp\command\WarpCommand;
use falkirks\simplewarp\lang\TranslationManager;
use falkirks\simplewarp\store\YAMLStore;
use falkirks\simplewarp\utils\WeakPosition;
use pocketmine\plugin\Plugin;
use pocketmine\plugin\PluginBase;
use pocketmine\utils\Config;

class SimpleWarp extends PluginBase{
    /** @var  SimpleWarpAPI */
    private $api;
    /** @var  WarpManager */
    private $warpManager;
    /** @var  TranslationManager */
    private $translationManager;

    public function onEnable(){
        $this->saveDefaultConfig();

        $this->api = new SimpleWarpAPI($this);
        $this->translationManager = new TranslationManager($this->api, new YAMLStore(new Config($this->getDataFolder() . "lang.yml", Config::YAML)));
        $this->warpManager = new WarpManager($this->api, new YAMLStore(new Config($this->getDataFolder() . "warps.yml", Config::YAML)), ($this->getConfig()->get('storage-mode') != null ? $this->getConfig()->get('storage-mode') : WarpManager::MEMORY_TILL_CLOSE));
        if($this->getServer()->getPluginManager()->getPlugin("EssentialsPE") instanceof Plugin && $this->getConfig()->get("essentials-support")){
            $this->getLogger()->info("Enabling EssentialsPE support...");
            $warpCommand = $this->getServer()->getCommandMap()->getCommand("warp");
            $delWarpCommand = $this->getServer()->getCommandMap()->getCommand("delwarp");

            $this->unregisterCommands([
                "warp",
                "delwarp"
            ]);

            $this->getServer()->getCommandMap()->registerAll("simplewarp", [
                new EssentialsWarpCommand($this->api, $warpCommand),
                new AddWarpCommand($this->api),
                new EssentialsDelWarpCommand($this->api, $delWarpCommand),
                new ListWarpsCommand($this->api),
                new OpenWarpCommand($this->api),
                new CloseWarpCommand($this->api)
            ]);


        }
        else {
            $this->getServer()->getCommandMap()->registerAll("simplewarp", [
                new WarpCommand($this->api),
                new AddWarpCommand($this->api),
                new DelWarpCommand($this->api),
                new ListWarpsCommand($this->api),
                new OpenWarpCommand($this->api),
                new CloseWarpCommand($this->api)
            ]);
        }
    }
    public function onDisable(){
        $this->warpManager->saveAll();
    }

    /**
     * @return WarpManager
     */
    public function getWarpManager(){
        return $this->warpManager;
    }

    /**
     * @return TranslationManager
     */
    public function getTranslationManager(){
        return $this->translationManager;
    }

    /**
     * @return mixed
     */
    public function getApi(){
        return $this->api;
    }

    /**
     * Function to easily disable commands
     *
     * @param array $commands
     */
    private function unregisterCommands(array $commands){
        $commandMap = $this->getServer()->getCommandMap();
        foreach($commands as $label){
            $command = $commandMap->getCommand($label);
            $command->setLabel($label . "_disabled");
            $command->unregister($commandMap);
        }
    }

}#    >=>>=>   >=>                         >=>           >=>        >=>
#  >=>    >=> >=>                         >=>           >=>        >=>
#   >=>       >=> >===>>=>>==>  >=> >=>   >=>   >==>    >=>   >>   >=>    >=> >=>  >> >==> >=> >=>
#     >=>     >=>  >=>  >>  >=> >>   >=>  >=> >>   >=>  >=>  >=>   >=>  >=>   >=>   >=>    >>   >=>
#        >=>  >=>  >=>  >>  >=> >>   >=>  >=> >>===>>=> >=> >> >=> >=> >=>    >=>   >=>    >>   >=>
#  >=>    >=> >=>  >=>  >>  >=> >=> >=>   >=> >>        >> >>    >===>  >=>   >=>   >=>    >=> >=>
#    >=>>=>   >=> >==>  >>  >=> >=>      >==>  >====>   >=>        >=>   >==>>>==> >==>    >=>
#                               >=>      The original warp plugin for PocketMine           >=>

display-exact-coordinates: false
  # If set to false the coordinates shown to the end user
  # will be rounded, players will still be teleported to the
  # exact location.
storage-mode: 0
  # SimpleWarp can handle the storage of warps in three main ways.
  #
  # MEMORY_TILL_CLOSE = 0
  # Warps are loaded into memory when the server starts and are
  # held there until the server closes. When the server closes
  # they are converted back into YAML. This new YAML will
  # replace warps.yml, this means that changes are lost and
  # warps which fail to load are discarded.
  #
  #
  # FLUSH_ON_CHANGE = 1
  # Warps are loaded into memory when the server starts. Whenever a
  # warp is updated, it will be updated in the warps.yml. When the
  # server closes, the warps file is NOT overwritten.
  #
  # NO_MEMORY_STORE = 2
  # Warps are never "stored" in memory. They are converted on demand
  # between YAML and object format. Any changes made to the config
  # will be available right away in the server and vice versa.
  #
essentials-support: false
  # If essentials-support is enabled and EssentialsPE is installed,
  # SimpleWarp will take steps to ensure compatibility between the
  # two plugins.<?php
namespace falkirks\simplewarp\api;


use falkirks\simplewarp\SimpleWarp;
use falkirks\simplewarp\Warp;
use pocketmine\Player;
use pocketmine\plugin\PluginBase;

/**
 * This class provides an API for interacting with
 * SimpleWarp, whenever possible, use methods from this
 * class instead of elsewhere.
 *
 * Class SimpleWarpAPI
 * @package falkirks\simplewarp\api
 */
class SimpleWarpAPI {
    private $plugin;
    public function __construct(SimpleWarp $simpleWarp){
        $this->plugin = $simpleWarp;
    }
    public function getSimpleWarp(){
        return $this->plugin;
    }
    public function getConfigItem($name){
        return $this->plugin->getConfig()->get($name);
    }
    public function executeTranslationItem($name, ...$args){
        return $this->plugin->getTranslationManager()->execute($name, ...$args);
    }
    public function getTranslationItem($name){
        return $this->plugin->getTranslationManager()->get($name);
    }

    /**
     * @param $name
     * @return Warp
     */
    public function getWarp($name){
        return $this->getWarpManager()[$name];
    }
    public function addWarp($name, Warp $warp){
        $this->getWarpManager()[$name] = $warp;
    }
    public function warpPlayerTo(Player $player, $name){
        $warp = $this->getWarp($name);
        if($warp instanceof Warp){
            $warp->teleport($player);
            return true;
        }
        return false;
    }
    public function canPlayerUse(Player $player, $name){
        $warp = $this->getWarp($name);
        if($warp instanceof Warp){
            return $warp->canUse($player);
        }
        return null;
    }
    public function getWarpManager(){
        return $this->plugin->getWarpManager();
    }
    public function isFastTransferLoaded(){
        return $this->getSimpleWarp()->getServer()->getPluginManager()->getPlugin("FastTransfer") instanceof PluginBase;
    }
    /**
     * This will hopefully save someone typing.
     * @param PluginBase $base
     * @return SimpleWarpAPI
     */
    public static function getInstance(PluginBase $base){
        return $base->getServer()->getPluginManager()->getPlugin("SimpleWarp")->getApi();
    }
}<?php
namespace falkirks\simplewarp\lang;


use falkirks\simplewarp\api\SimpleWarpAPI;
use falkirks\simplewarp\store\DataStore;
use falkirks\simplewarp\store\Reloadable;
use falkirks\simplewarp\store\Saveable;
use pocketmine\utils\TextFormat;

/**
 * This class is currently not implemented in any of SimpleWarp's utilities
 * Class TranslationManager
 * @package falkirks\simplewarp\lang
 */
class TranslationManager {
    /** @var  SimpleWarpAPI */
    private $api;
    /** @var  DataStore */
    private $store;

    public function __construct(SimpleWarpAPI $api, DataStore $store){
        $this->api = $api;
        $this->store = $store;
        $this->registerDefaults();
        $this->save();

    }
    public function get($name){
        return $this->store->get($name);
    }
    public function execute($name, ...$args){
        if($args === null || count($args) === 0){
            return $this->get($name);
        }
        if(is_array($args[0])){
            $args = $args[0];
        }
        return  sprintf($this->get($name), ...$args);
    }
    protected function registerDefaults(){
        $this->registerDefault("addwarp-cmd", "addwarp");
        $this->registerDefault("addwarp-desc", "Add new warps.");
        $this->registerDefault("addwarp-usage", "/addwarp <name> [<ip> <port>|<x> <y> <z> <level>|<player>]");
        $this->registerDefault("addwarp-event-cancelled", "A plugin has cancelled the creation of this warp.");

        $this->registerDefault("closewarp-cmd", "closewarp");
        $this->registerDefault("closewarp-desc", "Close existing warps.");
        $this->registerDefault("closewarp-usage", "/closewarp <name>");
        $this->registerDefault("closewarp-event-cancelled", "A plugin has cancelled this action.");

        $this->registerDefault("delwarp-cmd", "delwarp");
        $this->registerDefault("delwarp-desc", "Delete existing warps.");
        $this->registerDefault("delwarp-usage", "/delwarp <name>");
        $this->registerDefault("delewarp-event-cancelled", "A plugin has cancelled the deletion of this warp.");

        $this->registerDefault("listwarps-cmd", "listwarps");
        $this->registerDefault("listwarps-desc", "List all your warps.");
        $this->registerDefault("listwarps-usage", "/listwarps");
        $this->registerDefault("listwarps-list-title", "Warp list:\n");
        $this->registerDefault("listwarps-no-warps",  TextFormat::RED . "No warps found." . TextFormat::RESET);
        $this->registerDefault("listwarps-noperm", TextFormat::RED . "You don't have permission to use this command" . TextFormat::RESET);

        $this->registerDefault("openwarp-cmd", "openwarp");
        $this->registerDefault("openwarp-desc", "Open existing warps.");
        $this->registerDefault("openwarp-usage", "/openwarp <name>");
        $this->registerDefault("delwarp-event-cancelled", "A plugin has cancelled this action.");

        $this->registerDefault("warp-cmd", "warp");
        $this->registerDefault("warp-desc", "Warp around your world.");
        $this->registerDefault("warp-usage", "/warp <name> [player]");

        $this->registerDefault("warp-added-xyz", "You have created a warp called " . TextFormat::AQUA . "%s" . TextFormat::RESET . " %s");
        $this->registerDefault("warp-added-player", "You have created a warp called " . TextFormat::AQUA . "%s" . TextFormat::RESET . " %s");
        $this->registerDefault("warp-added-server", "You have created a warp called " . TextFormat::AQUA . "%s" . TextFormat::RESET . " %s");
        $this->registerDefault("warp-added-self", "You have created a warp called " . TextFormat::AQUA . "%s" . TextFormat::RESET . " %s");

        $this->registerDefault("level-not-loaded", TextFormat::RED . "You specified a level which isn't loaded." . TextFormat::RESET);

        $this->registerDefault("needs-fast-transfer", "This warp needs " . TextFormat::AQUA . "FastTransfer" . TextFormat::RESET . ", you will need to install it to use this warp.");

        $this->registerDefault("player-not-loaded", TextFormat::RED . "You specified a player which isn't loaded." . TextFormat::RESET);

        $this->registerDefault("addwarp-noperm", TextFormat::RED . "You don't have permission to use this command" . TextFormat::RESET);

        $this->registerDefault("bad-warp-name", TextFormat::RED . "That warp name is invalid." . TextFormat::RESET);

        $this->registerDefault("closed-warp-1", "You have closed a warp called " . TextFormat::AQUA . "%s" . TextFormat::RESET);
        $this->registerDefault("closed-warp-2", "  Only players with the permission " . TextFormat::AQUA . "%s" . TextFormat::RESET . " will be able to use this warp.");
        $this->registerDefault("warp-doesnt-exist", TextFormat::RED . "That warp doesn't exist." . TextFormat::RESET);
        $this->registerDefault("closewarp-noperm", TextFormat::RED . "You don't have permission to use this command" . TextFormat::RESET);

        $this->registerDefault("warp-deleted", "You have deleted a warp called " . TextFormat::AQUA . "%s" . TextFormat::RESET);
        $this->registerDefault("delwarp-noperm", TextFormat::RED . "You don't have permission to use this command" . TextFormat::RESET);

        $this->registerDefault("opened-warp-1", "You have opened a warp called " . TextFormat::AQUA . "%s" . TextFormat::RESET);
        $this->registerDefault("opened-warp-2", "  Any player will be able to use this warp.");
        $this->registerDefault("openwarp-noperm", TextFormat::RED . "You don't have permission to use this command" . TextFormat::RESET);

        $this->registerDefault("warping-popup", "Warping...");
        $this->registerDefault("other-player-warped", "%s  has been warped to " . TextFormat::AQUA . "%s" . TextFormat::RESET . ".");
        $this->registerDefault("no-permission-this-warp", TextFormat::RED . "You don't have permission to use this warp." . TextFormat::RESET);
        $this->registerDefault("no-permission-warp-other", TextFormat::RED . "You don't have permission to warp other players." . TextFormat::RESET);
        $this->registerDefault("warp-done", "You have been warped");
        $this->registerDefault("warp-noperm", TextFormat::RED . "You don't have permission to use this command" . TextFormat::RESET);

        $this->registerDefault("level-not-loaded-warp", "The warp you are using is attached to a level which isn't loaded");

        $this->registerDefault("ess-warp-doesnt-exist", TextFormat::RED . "That warp doesn't exist." . TextFormat::RESET);
        $this->registerDefault("ess-warp-conflict",  "The warp called " . TextFormat::AQUA . "%s" . TextFormat::RESET . " exists in both " . TextFormat::AQUA . "EssentialsPE" . TextFormat::RESET . " and " . TextFormat::AQUA . "SimpleWarp" . TextFormat::RESET . ". The one from " . TextFormat::AQUA . "SimpleWarp" . TextFormat::RESET . " will be used by default. If you wish to use the " . TextFormat::AQUA . "EssentialsPE" . TextFormat::RESET . " warp, prefix the warp name with " . TextFormat::DARK_AQUA . "ess:" . TextFormat::RESET);

        $this->registerDefault("addwarp-ess-prefix-warning", "Support for " . TextFormat::AQUA . "EssentialsPE" . TextFormat::RESET . " is enabled on this server. When a user wants to explicitly use an " . TextFormat::AQUA . "EssentialsPE" . TextFormat::RESET . " warp, they can prefix their command with " . TextFormat::DARK_AQUA . "ess:" . TextFormat::RESET . ". By choosing to pick a warp name that starts with the same prefix, you are making things complicated. Maybe pick a different name?");

    }
    protected function registerDefault($name, $text){
        if(!$this->store->exists($name)){
            $this->store->add($name, $text);
        }
    }
    public function reload(){
        if($this->store instanceof Reloadable){
            $this->store->reload();
        }
    }
    protected function save(){
        if($this->store instanceof Saveable){
            $this->store->save();
        }
    }

}<?php
/**
 * Created by PhpStorm.
 * User: noahheyl
 * Date: 2015-06-04
 * Time: 8:18 PM
 */

namespace falkirks\simplewarp\store;


use pocketmine\utils\Config;

class YAMLStore extends StandardStore implements Saveable, Reloadable{
    /** @var Config  */
    private $config;
    public function __construct(Config $config){
        $this->config = $config;
    }

    public function add($name, $warp){
        $past = $this->config->get($name, null);
        $this->config->set($name, $warp);
        $this->config->save();
        return $past;
    }
    public function get($name){
        return $this->config->get($name, null);
    }

    public function remove($name){
        $past = $this->config->get($name, null);
        $this->config->remove($name);
        $this->config->save();
        return $past;
    }

    public function clear(){
        $this->config->setAll([]);
        $this->config->save();
    }

    public function reload(){
        $this->config->reload();
    }
    /**
     * Returns something which can be used to iterate
     * over the store.
     * @return mixed
     */
    public function getIterator(){
       return $this->config->getAll();
    }

    public function save(){
        $this->config->save();
    }

}<?php

namespace falkirks\simplewarp\store;


abstract class StandardStore implements DataStore{
    public function addAll($warps){
        foreach($warps as $name => $warp){
            $this->add($name, $warp);
        }
    }
    public function removeAll($warps){
        foreach($warps as $warp){
            $this->remove($warp);
        }
    }
    public function exists($name){
        return $this->get($name) !== null;
    }

}<?php
namespace falkirks\simplewarp\store;

/**
 * This interface deals with the storage of arbitrary warp
 * data in a key-value store.
 *
 * Interface WarpStore
 * @package falkirks\simplewarp\store
 */
interface DataStore {
    public function addAll($warps);
    public function removeAll($warps);
    public function exists($name);

    /**
     * This method takes a $name string and a $warp array and
     * returns the previous value that occupied $name or null.
     * @param $name
     * @param $warp
     * @return mixed
     */
    public function add($name, $warp);

    /**
     * @param $name
     * @return mixed
     */
    public function get($name);
    public function remove($name);
    public function clear();

    /**
     * Returns something which can be used to iterate
     * over the store.
     * @return mixed
     */
    public function getIterator();
}<?php
/**
 * Created by PhpStorm.
 * User: noahheyl
 * Date: 2015-06-04
 * Time: 8:28 PM
 */

namespace falkirks\simplewarp\store;


interface Saveable extends DataStore{
    public function save();
}<?php
namespace falkirks\simplewarp\store;


interface Reloadable extends DataStore{
    public function reload();
}<?php
namespace falkirks\simplewarp;


use falkirks\simplewarp\api\SimpleWarpAPI;
use falkirks\simplewarp\store\DataStore;
use falkirks\simplewarp\store\Reloadable;
use falkirks\simplewarp\store\Saveable;
use falkirks\simplewarp\utils\WeakPosition;
use pocketmine\level\Level;
use pocketmine\level\Position;
use pocketmine\network\protocol\DataPacket;
use pocketmine\utils\TextFormat;
use Traversable;

class WarpManager implements \ArrayAccess, \IteratorAggregate{
    const MEMORY_TILL_CLOSE = 0;
    const FLUSH_ON_CHANGE = 1;
    /**
     * This option is pretty scary :(
     */
    const NO_MEMORY_STORE = 2;

    /** @var SimpleWarpAPI  */
    private $api;
    /** @var DataStore  */
    private $store;

    /** @var  Warp[] */
    private $warps;

    private $flag;

    public function __construct(SimpleWarpAPI $api, DataStore $store, $flag = WarpManager::MEMORY_TILL_CLOSE){
        $this->api = $api;
        $this->store = $store;
        $this->flag = $flag;
        $this->warps = [];
        if($this->flag < 2){
            $this->warps = $this->loadWarps();
        }
    }
    protected function reloadStore(){
        if($this->flag >= 2 && $this->store instanceof Reloadable){
            $this->store->reload();
        }
    }
    protected function saveStore($force = false){
        if(($this->flag > 0 || $force) && $this->store instanceof Saveable){
            $this->store->save();
        }
    }
    protected function loadWarps(){
        $out = [];
        foreach($this->store->getIterator() as $name => $data){
            $out[$name] = $this->warpFromData($name, $data);
        }
        return $out;
    }
    /**
     * WARNING
     * This function is for internal use only.
     */
    public function saveAll(){
        if($this->flag === 0){
            $this->store->clear();
            foreach($this->warps as $warp){
                $this->store->add($warp->getName(), $this->warpToData($warp));
            }
            $this->saveStore(true);
        }
    }
    /**
     * (PHP 5 &gt;= 5.0.0)<br/>
     * Whether a offset exists
     * @link http://php.net/manual/en/arrayaccess.offsetexists.php
     * @param mixed $offset <p>
     * An offset to check for.
     * </p>
     * @return boolean true on success or false on failure.
     * </p>
     * <p>
     * The return value will be casted to boolean if non-boolean was returned.
     */
    public function offsetExists($offset){
        $this->reloadStore();
        if(isset($this->warps[$offset]) || ($this->flag >= 2 && $this->store->exists($offset))){
            return true;
        }
        return false;
    }

    /**
     * (PHP 5 &gt;= 5.0.0)<br/>
     * Offset to retrieve
     * @link http://php.net/manual/en/arrayaccess.offsetget.php
     * @param mixed $offset <p>
     * The offset to retrieve.
     * </p>
     * @return mixed Can return all value types.
     */
    public function offsetGet($offset){
        if($this->flag >= 2){
            $this->reloadStore();
            return $this->warpFromData($offset, $this->store->get($offset));
        }
        return isset($this->warps[$offset]) ? $this->warps[$offset] : null;
    }

    /**
     * (PHP 5 &gt;= 5.0.0)<br/>
     * Offset to set
     * @link http://php.net/manual/en/arrayaccess.offsetset.php
     * @param mixed $offset <p>
     * The offset to assign the value to.
     * </p>
     * @param mixed $value <p>
     * The value to set.
     * </p>
     * @return void
     */
    public function offsetSet($offset, $value){
        if($value instanceof Warp && $value->getName() === $offset) {
            if($this->flag < 2) {
                $this->warps[$offset] = $value;
            }

            if ($this->flag >= 1) {
                $this->store->add($offset, $this->warpToData($value));
                $this->saveStore();
            }
        }
        else{
            //TODO report failure
        }
    }

    /**
     * (PHP 5 &gt;= 5.0.0)<br/>
     * Offset to unset
     * @link http://php.net/manual/en/arrayaccess.offsetunset.php
     * @param mixed $offset <p>
     * The offset to unset.
     * </p>
     * @return void
     */
    public function offsetUnset($offset){
        if($this->flag < 2){
            unset($this->warps[$offset]);
        }

        if($this->flag >= 1){
            $this->store->remove($offset);
            $this->saveStore();
        }
    }

    /**
     * This method requires the key of the warp in order
     * to construct a warp object
     * @param $name
     * @param array $array
     * @return Warp
     * @throws \Exception
     */
    protected function warpFromData($name, array $array){
        if(isset($array["level"]) && isset($array["x"]) && isset($array["y"]) && isset($array["z"]) && isset($array["public"])){ // This is an internal warp
            return new Warp($name, new Destination(new WeakPosition($array["x"], $array["y"], $array["z"], $array["level"])), $array["public"]);
        }
        elseif(isset($array["address"]) && isset($array["port"]) && isset($array["public"])) {
            return new Warp($name, new Destination($array["address"], $array["port"]), $array["public"]);
        }

        $this->api->getSimpleWarp()->getLogger()->critical("A warp with the name " . TextFormat::AQUA . $name . TextFormat::RESET . " is incomplete. It will be removed automatically when your server stops.");
        return null;
    }

    /**
     * In order to pass data to a DataStore
     * a key is needed. Typically one should
     * use $warp->getName()
     * @param Warp $warp
     * @return array
     */
    protected function warpToData(Warp $warp){
        if($warp->getDestination()->isInternal()) {
            //TODO implement yaw and pitch
            $pos = $warp->getDestination()->getPosition();
            return [
                "x" => $pos->getX(),
                "y" => $pos->getY(),
                "z" => $pos->getZ(),
                "level" => ($pos instanceof WeakPosition ? $pos->getLevelName() : $pos->getLevel()->getName()),
                "public" => $warp->isPublic()
            ];
        }
        return [
            "address" => $warp->getDestination()->getAddress(),
            "port" => $warp->getDestination()->getPort(),
            "public" => $warp->isPublic()
        ];
    }

    /**
     * (PHP 5 &gt;= 5.0.0)<br/>
     * Retrieve an external iterator
     * @link http://php.net/manual/en/iteratoraggregate.getiterator.php
     * @return Traversable An instance of an object implementing <b>Iterator</b> or
     * <b>Traversable</b>
     */
    public function getIterator(){
        if($this->flag >= 2){
            return $this->loadWarps();
        }
        return $this->warps;
    }

}<?php
namespace falkirks\simplewarp\command;


use falkirks\simplewarp\api\SimpleWarpAPI;
use falkirks\simplewarp\permission\SimpleWarpPermissions;
use falkirks\simplewarp\Version;
use falkirks\simplewarp\Warp;
use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\command\PluginIdentifiableCommand;
use pocketmine\level\particle\ExplodeParticle;
use pocketmine\level\particle\FloatingTextParticle;
use pocketmine\level\particle\SmokeParticle;
use pocketmine\level\Position;
use pocketmine\math\Vector3;
use pocketmine\Player;
use pocketmine\utils\Random;
use pocketmine\utils\TextFormat;

class WarpCommand extends Command implements PluginIdentifiableCommand{
    protected $api;
    public function __construct(SimpleWarpAPI $api){
        parent::__construct($api->executeTranslationItem("warp-cmd"), $api->executeTranslationItem("warp-desc"), $api->executeTranslationItem("warp-usage"));
        $this->api = $api;
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param string[] $args
     *
     * @return mixed
     */
    public function execute(CommandSender $sender, $commandLabel, array $args){
        if($sender->hasPermission(SimpleWarpPermissions::WARP_COMMAND)){
            if(isset($args[0])){
                if(isset($this->api->getWarpManager()[$args[0]])) {
                    if (isset($args[1])) {
                        if($sender->hasPermission(SimpleWarpPermissions::WARP_OTHER_COMMAND)) {
                            if (($player = $this->api->getSimpleWarp()->getServer()->getPlayer($args[1])) instanceof Player) {
                                /** @var Warp $warp */
                                $warp = $this->api->getWarpManager()[$args[0]];
                                if ($warp->canUse($sender)) {
                                    $this->displaySmoke($player);
                                    $player->sendPopup($this->api->executeTranslationItem("warping-popup", $args[0]));
                                    $warp->teleport($player);
                                    $sender->sendMessage($this->api->executeTranslationItem("other-player-warped", $player->getName(), $args[0]));
                                }
                                else{
                                    $sender->sendMessage($this->api->executeTranslationItem("no-permission-warp"));
                                }
                            }
                            else {
                                $sender->sendMessage($this->api->executeTranslationItem("player-not-loaded"));
                            }
                        }
                        else{
                            $sender->sendMessage($this->api->executeTranslationItem("no-permission-warp-other"));
                        }
                    }
                    elseif ($sender instanceof Player) {
                        /** @var Warp $warp */
                        $warp = $this->api->getWarpManager()[$args[0]];
                        if($warp->canUse($sender)){
                            $this->displaySmoke($sender);
                            $sender->sendPopup($this->api->executeTranslationItem("warping-popup", $args[0]));
                            $warp->teleport($sender);
                            $sender->sendMessage($this->api->executeTranslationItem("warp-done"));
                        }
                        else{
                            $sender->sendMessage($this->api->executeTranslationItem("no-permission-warp"));
                        }
                    }
                    else {
                        $sender->sendMessage($this->getUsage());

                    }
                }
                else{
                    $sender->sendMessage($this->api->executeTranslationItem("warp-doesnt-exist"));
                }
            }
            else{
                $sender->sendMessage($this->getUsage());
                Version::sendVersionMessage($sender);
            }
        }
        else{
            $sender->sendMessage($this->api->executeTranslationItem("warp-noperm"));
        }
    }
    public function displaySmoke(Position $pos){
        //particle smoke 120 71 124 1 1 1 35 200
        $random = new Random((int) (microtime(true) * 1000) + mt_rand());

        $particle = new SmokeParticle(new Vector3($pos->x, $pos->y + 0.7, $pos->z), 200);
        for($i = 0; $i < 35; ++$i){
            $particle->setComponents(
                $pos->x + $random->nextSignedFloat(),
                $pos->y + $random->nextSignedFloat(),
                $pos->z + $random->nextSignedFloat()
            );
            $pos->getLevel()->addParticle($particle);
        }
    }

    /**
     * @return \pocketmine\plugin\Plugin
     */
    public function getPlugin(){
        return $this->api->getSimpleWarp();
    }
}<?php
namespace falkirks\simplewarp\command;


use falkirks\simplewarp\api\SimpleWarpAPI;
use falkirks\simplewarp\Destination;
use falkirks\simplewarp\event\WarpAddEvent;
use falkirks\simplewarp\permission\SimpleWarpPermissions;
use falkirks\simplewarp\utils\WeakPosition;
use falkirks\simplewarp\Version;
use falkirks\simplewarp\Warp;
use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\command\PluginIdentifiableCommand;
use pocketmine\level\Level;
use pocketmine\level\Position;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class AddWarpCommand extends Command implements PluginIdentifiableCommand{
    private $api;
    public function __construct(SimpleWarpAPI $api){
        parent::__construct($api->executeTranslationItem("addwarp-cmd"), $api->executeTranslationItem("addwarp-desc"), $api->executeTranslationItem("addwarp-usage"));
        $this->api = $api;
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param string[] $args
     *
     * @return mixed
     */
    public function execute(CommandSender $sender, $commandLabel, array $args){
        if($sender->hasPermission(SimpleWarpPermissions::ADD_WARP_COMMAND)){
            if(isset($args[0])) {
                if(!isset($this->api->getWarpManager()[$args[0]])) {
                    if(substr($args[0], 0, 4) === "ess:" && $this->api->getConfigItem("essentials-support") && $sender->hasPermission("simplewarp.essentials.notice")){
                        $sender->sendMessage($this->api->executeTranslationItem("addwarp-ess-prefix-warning"));
                    }
                    if (isset($args[4])) {
                        $level = $this->api->getSimpleWarp()->getServer()->getLevelByName($args[4]);
                        if ($level instanceof Level) {
                            $dest = new Destination(new WeakPosition($args[1], $args[2], $args[3], $args[4]));
                            $warp = new Warp($args[0], $dest);
                            $ev = new WarpAddEvent($sender, $warp);
                            $this->getPlugin()->getServer()->getPluginManager()->callEvent($ev);
                            if(!$ev->isCancelled()) {
                                $this->api->getWarpManager()[$args[0]] = $warp;
                                $sender->sendMessage($this->api->executeTranslationItem("warp-added-xyz", $args[0], $dest->toString()));
                            }
                            else{
                                $sender->sendMessage($this->api->executeTranslationItem("addwarp-event-cancelled"));
                            }
                        }
                        else {
                            $sender->sendMessage($this->api->executeTranslationItem("level-not-loaded"));
                        }
                    }
                    elseif (isset($args[2])) {
                        $dest = new Destination($args[1], $args[2]);
                        $warp = new Warp($args[0], $dest);
                        $ev = new WarpAddEvent($sender, $warp);
                        $this->getPlugin()->getServer()->getPluginManager()->callEvent($ev);
                        if(!$ev->isCancelled()){
                            $this->api->getWarpManager()[$args[0]] = $warp;
                            $sender->sendMessage($this->api->executeTranslationItem("warp-added-server", $args[0], $dest->toString()));
                            if (!$this->api->isFastTransferLoaded()) {
                                $sender->sendMessage($this->api->executeTranslationItem("needs-fast-transfer"));
                            }
                        }
                        else{
                            $sender->sendMessage($this->api->executeTranslationItem("addwarp-event-cancelled"));
                        }
                    }
                    elseif (isset($args[1])) {
                        if (($player = $this->api->getSimpleWarp()->getServer()->getPlayer($args[1])) instanceof Player) {
                            $dest = new Destination(new Position($player->getX(), $player->getY(), $player->getZ(), $player->getLevel()));
                            $warp = new Warp($args[0], $dest);
                            $ev = new WarpAddEvent($sender, $warp);
                            $this->getPlugin()->getServer()->getPluginManager()->callEvent($ev);
                            if(!$ev->isCancelled()) {
                                $this->api->getWarpManager()[$args[0]] = $warp;
                                $sender->sendMessage($this->api->executeTranslationItem("warp-added-player", $args[0], $dest->toString()));
                            }
                            else{
                                $sender->sendMessage($this->api->executeTranslationItem("addwarp-event-cancelled"));
                            }
                        }
                        else {
                            $sender->sendMessage($this->api->executeTranslationItem("player-not-loaded"));
                        }
                    }
                    else {
                        if ($sender instanceof Player) {
                            $dest = new Destination(new Position($sender->getX(), $sender->getY(), $sender->getZ(), $sender->getLevel()));
                            $warp = new Warp($args[0], $dest);
                            $ev = new WarpAddEvent($sender, $warp);
                            $this->getPlugin()->getServer()->getPluginManager()->callEvent($ev);
                            if(!$ev->isCancelled()) {
                                $this->api->getWarpManager()[$args[0]] = $warp;
                                $sender->sendMessage($this->api->executeTranslationItem("warp-added-self", $args[0], $dest->toString()));
                            }
                            else{
                                $sender->sendMessage($this->api->executeTranslationItem("addwarp-event-cancelled"));
                            }
                        }
                        else {
                            $sender->sendMessage($this->getUsage());
                        }
                    }
                }
                else{
                    $sender->sendMessage($this->api->executeTranslationItem("bad-warp-name"));
                }
            }
            else{
                $sender->sendMessage($this->getUsage());
                Version::sendVersionMessage($sender);
            }
        }
        else{
            $sender->sendMessage($this->api->executeTranslationItem("addwarp-no-perm"));
        }
    }


    /**
     * @return \pocketmine\plugin\Plugin
     */
    public function getPlugin(){
        return $this->api->getSimpleWarp();
    }
}<?php
namespace falkirks\simplewarp\command;


use falkirks\simplewarp\api\SimpleWarpAPI;
use falkirks\simplewarp\event\WarpDeleteEvent;
use falkirks\simplewarp\permission\SimpleWarpPermissions;
use falkirks\simplewarp\Version;
use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\command\PluginIdentifiableCommand;
use pocketmine\utils\TextFormat;

class DelWarpCommand extends Command implements PluginIdentifiableCommand{
    protected $api;
    public function __construct(SimpleWarpAPI $api){
        parent::__construct($api->executeTranslationItem("delwarp-cmd"), $api->executeTranslationItem("delwarp-desc"), $api->executeTranslationItem("delwarp-usage"));
        $this->api = $api;
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param string[] $args
     *
     * @return mixed
     */
    public function execute(CommandSender $sender, $commandLabel, array $args){
        if($sender->hasPermission(SimpleWarpPermissions::DEL_WARP_COMMAND)){
            if(isset($args[0])){
                if(isset($this->api->getWarpManager()[$args[0]])) {
                    $ev = new WarpDeleteEvent($sender, $this->api->getWarpManager()[$args[0]]);
                    $this->getPlugin()->getServer()->getPluginManager()->callEvent($ev);
                    if(!$ev->isCancelled()){
                        unset($this->api->getWarpManager()[$args[0]]);
                        $sender->sendMessage($this->api->executeTranslationItem("warp-deleted", $args[0]));
                    }
                    else{
                        $sender->sendMessage($this->api->executeTranslationItem("delwarp-event-cancelled"));
                    }
                }
                else{
                    $sender->sendMessage($this->api->executeTranslationItem("warp-doesnt-exist", $args[0]));
                }
            }
            else{
                $sender->sendMessage($this->getUsage());
                Version::sendVersionMessage($sender);
            }
        }
        else{
            $sender->sendMessage($this->api->executeTranslationItem("delwarp-noperm"));
        }
    }


    /**
     * @return \pocketmine\plugin\Plugin
     */
    public function getPlugin(){
        return $this->api->getSimpleWarp();
    }
}<?php
namespace falkirks\simplewarp\command;


use falkirks\simplewarp\api\SimpleWarpAPI;
use falkirks\simplewarp\permission\SimpleWarpPermissions;
use falkirks\simplewarp\Warp;
use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\command\PluginIdentifiableCommand;
use pocketmine\level\particle\FloatingTextParticle;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class ListWarpsCommand extends Command implements PluginIdentifiableCommand{
    private $api;
    public function __construct(SimpleWarpAPI $api){
        parent::__construct($api->executeTranslationItem("listwarps-cmd"), $api->executeTranslationItem("listwarps-desc"), $api->executeTranslationItem("listwarps-usage"));
        $this->api = $api;
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param string[] $args
     *
     * @return mixed
     */
    public function execute(CommandSender $sender, $commandLabel, array $args){
        if($sender->hasPermission(SimpleWarpPermissions::LIST_WARPS_COMMAND)){
            $ret = $this->api->executeTranslationItem("listwarps-list-title");
            /** @var Warp[] $iterator */
            $iterator = $this->api->getWarpManager()->getIterator();
            foreach($iterator as $w){
                if($w->canUse($sender)){
                    $ret .= " * " . $w->getName() .  " ";
                    if($sender->hasPermission(SimpleWarpPermissions::LIST_WARPS_COMMAND_XYZ)){
                        $dest = $w->getDestination();
                        $ret .= $dest->toString();
                    }
                    $ret .= "\n";
                }
            }
            /**
             * EASTER EGG!
             */
            if($sender instanceof Player && $sender->hasPermission(SimpleWarpPermissions::LIST_WARPS_COMMAND_VISUAL) && isset($args[0]) && $args[0] === "v"){
                foreach($iterator as $warp){
                    if($warp->getDestination()->isInternal() && $warp->getDestination()->getPosition()->getLevel() === $sender->getLevel()){
                        $particle = new FloatingTextParticle($warp->getDestination()->getPosition(), "(X: {$warp->getDestination()->getPosition()->getFloorX()}}, Y: {$warp->getDestination()->getPosition()->getFloorY()}, Z: {$warp->getDestination()->getPosition()->getFloorZ()}, LEVEL: {$warp->getDestination()->getPosition()->getLevel()->getName()})", "WARP: " . TextFormat::AQUA . $warp->getName() . TextFormat::RESET);
                        $sender->getLevel()->addParticle($particle, [$sender]);
                    }
                }
            }
            $sender->sendMessage(($ret !== $this->api->executeTranslationItem("listwarps-list-title") ? $ret : $this->api->executeTranslationItem("listwarps-no-warps")));
        }
        else{
            $sender->sendMessage($this->api->executeTranslationItem("listwarps-noperm"));
        }
    }


    /**
     * @return \pocketmine\plugin\Plugin
     */
    public function getPlugin(){
        return $this->api->getSimpleWarp();
    }
}<?php
namespace falkirks\simplewarp\command;


use falkirks\simplewarp\api\SimpleWarpAPI;
use falkirks\simplewarp\event\WarpOpenEvent;
use falkirks\simplewarp\permission\SimpleWarpPermissions;
use falkirks\simplewarp\Version;
use falkirks\simplewarp\Warp;
use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\command\PluginIdentifiableCommand;
use pocketmine\utils\TextFormat;

class OpenWarpCommand extends Command implements PluginIdentifiableCommand{
    private $api;
    public function __construct(SimpleWarpAPI $api){
        parent::__construct($api->executeTranslationItem("openwarp-cmd"), $api->executeTranslationItem("openwarp-desc"), $api->executeTranslationItem("openwarp-usage"));
        $this->api = $api;
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param string[] $args
     *
     * @return mixed
     */
    public function execute(CommandSender $sender, $commandLabel, array $args){
        if($sender->hasPermission(SimpleWarpPermissions::OPEN_WARP_COMMAND)){
            if(isset($args[0])){
                if(isset($this->api->getWarpManager()[$args[0]])) {
                    /** @var Warp $warp */
                    $warp = $this->api->getWarpManager()[$args[0]];
                    $ev = new WarpOpenEvent($sender, $warp);
                    $this->getPlugin()->getServer()->getPluginManager()->callEvent($ev);
                    if(!$ev->isCancelled()){
                        $warp->setPublic(true);
                        $this->api->getWarpManager()[$args[0]] = $warp;
                        $sender->sendMessage($this->api->executeTranslationItem("opened-warp-1", $args[0]));
                        $sender->sendMessage($this->api->executeTranslationItem("opened-warp-2"));
                    }
                    else{
                        $sender->sendMessage($this->api->executeTranslationItem("openwarp-event-cancelled"));
                    }
                }
                else{
                    $sender->sendMessage($this->api->executeTranslationItem("warp-doesnt-exist", $args[0]));
                }
            }
            else{
                $sender->sendMessage($this->getUsage());
                Version::sendVersionMessage($sender);
            }
        }
        else{
            $sender->sendMessage($this->api->executeTranslationItem("openwarp-noperm"));
        }
    }


    /**
     * @return \pocketmine\plugin\Plugin
     */
    public function getPlugin(){
        return $this->api->getSimpleWarp();
    }
}<?php
namespace falkirks\simplewarp\command;


use falkirks\simplewarp\api\SimpleWarpAPI;
use falkirks\simplewarp\event\WarpCloseEvent;
use falkirks\simplewarp\permission\SimpleWarpPermissions;
use falkirks\simplewarp\Version;
use falkirks\simplewarp\Warp;
use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\command\PluginIdentifiableCommand;
use pocketmine\utils\TextFormat;

class CloseWarpCommand extends Command implements PluginIdentifiableCommand{
    private $api;
    public function __construct(SimpleWarpAPI $api){
        parent::__construct($api->executeTranslationItem("closewarp-cmd"), $api->executeTranslationItem("closewarp-desc"), $api->executeTranslationItem("closewarp-usage"));
        $this->api = $api;
    }

    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param string[] $args
     *
     * @return mixed
     */
    public function execute(CommandSender $sender, $commandLabel, array $args){
        if($sender->hasPermission(SimpleWarpPermissions::OPEN_WARP_COMMAND)){
            if(isset($args[0])){
                if(isset($this->api->getWarpManager()[$args[0]])) {
                    /** @var Warp $warp */
                    $warp = $this->api->getWarpManager()[$args[0]];
                    $ev = new WarpCloseEvent($sender, $warp);
                    $this->getPlugin()->getServer()->getPluginManager()->callEvent($ev);
                    if(!$ev->isCancelled()){
                        $warp->setPublic(false);
                        $this->api->getWarpManager()[$args[0]] = $warp;
                        $sender->sendMessage($this->api->executeTranslationItem("closed-warp-1", $args[0]));
                        $sender->sendMessage($this->api->executeTranslationItem("closed-warp-2", SimpleWarpPermissions::BASE_WARP_PERMISSION . "." . $warp->getName()));
                    }
                    else{
                        $sender->sendMessage($this->api->executeTranslationItem("closewarp-event-cancelled"));
                    }
                }
                else{
                    $sender->sendMessage($this->api->executeTranslationItem("warp-doesnt-exist"));
                }
            }
            else{
                $sender->sendMessage($this->getUsage());
                Version::sendVersionMessage($sender);
            }
        }
        else{
            $sender->sendMessage($this->api->executeTranslationItem("closewarp-noperm"));
        }
    }


    /**
     * @return \pocketmine\plugin\Plugin
     */
    public function getPlugin(){
        return $this->api->getSimpleWarp();
    }
}