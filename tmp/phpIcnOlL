name: MineReset
main: falkirks\minereset\MineReset
version: 3.0
author: Falk
api: [1.0.0, 2.0.0, 3.0.0-ALPHA1, 3.0.0-ALPHA2, 3.0.0-ALPHA3, 3.0.0-ALPHA4, 3.0.0-ALPHA5]
load: POSTWORLD
permissions:
 minereset:
  default: op
  children:
   minereset.command:
    default: op
    description: Use MineReset commands
    children:
      minereset.command.about:
        description: Read the about text
      minereset.command.create:
        description: Add new Mines
      minereset.command.set:
        description: Set existing mines
      minereset.command.reset:
        description: Reset mines
      minereset.command.destroy:
        description: Remove mines
      minereset.command.resetall:
        description: Reset all mines<?php
namespace falkirks\minereset;


use falkirks\minereset\command\AboutCommand;
use falkirks\minereset\command\CreateCommand;
use falkirks\minereset\command\DestroyCommand;
use falkirks\minereset\command\ListCommand;
use falkirks\minereset\command\MineCommand;
use falkirks\minereset\command\ResetAllCommand;
use falkirks\minereset\command\ResetCommand;
use falkirks\minereset\command\SetCommand;
use falkirks\minereset\listener\CreationListener;
use falkirks\minereset\listener\RegionBlockerListener;
use falkirks\minereset\store\EntityStore;
use falkirks\minereset\store\YAMLStore;
use falkirks\minereset\task\ScheduledResetTaskPool;
use pocketmine\level\Level;
use pocketmine\plugin\PluginBase;
use pocketmine\utils\Config;


/**
 * MineReset is a powerful mine resetting tool for PocketMine
 *
 * Class MineReset
 * @package falkirks\minereset
 */
class MineReset extends PluginBase{

    /** @var  MineManager */
    private $mineManager;
    /** @var  ResetProgressManager */
    private $resetProgressManager;
    /** @var  RegionBlockerListener */
    private $regionBlockerListener;
    /** @var  MineCommand */
    private $mainCommand;
    /** @var  bool */
    private static $supportsChunkSetting = null;

    /** @var  CreationListener */
    private $creationListener;

    public function onEnable(){
        self::detectChunkSetting();

        @mkdir($this->getDataFolder());

        $this->mineManager = new MineManager($this, new YAMLStore(new Config($this->getDataFolder() . "mines.yml", Config::YAML, [])));

        $this->resetProgressManager = new ResetProgressManager($this);

        $this->regionBlockerListener = new RegionBlockerListener($this);
        $this->getServer()->getPluginManager()->registerEvents($this->regionBlockerListener, $this);

        $this->creationListener = new CreationListener($this);
        $this->getServer()->getPluginManager()->registerEvents($this->creationListener, $this);

        $this->mainCommand = new MineCommand($this);
        $this->getServer()->getCommandMap()->register("minereset", $this->mainCommand);

        $this->mainCommand->registerSubCommand("about", new AboutCommand($this), ['a']);
        $this->mainCommand->registerSubCommand("list", new ListCommand($this), ['l']);
        $this->mainCommand->registerSubCommand("create", new CreateCommand($this), ['c']);
        $this->mainCommand->registerSubCommand("set", new SetCommand($this), ['s']);
        $this->mainCommand->registerSubCommand("destroy", new DestroyCommand($this), ['d']);
        $this->mainCommand->registerSubCommand("reset", new ResetCommand($this), ['r']);
        $this->mainCommand->registerSubCommand("reset-all", new ResetAllCommand($this), ['ra']);

        if(!self::supportsChunkSetting()){
            $this->getLogger()->warning("Your server does not support setting chunks without unloading them. This will cause tiles and entities to be lost when resetting mines. Upgrade to a newer pmmp to resolve this.");
        }

    }

    public function onDisable(){
        $this->mineManager->saveAll();
    }

    /**
     * @return MineManager
     */
    public function getMineManager(): MineManager{
        return $this->mineManager;
    }

    /**
     * @return ResetProgressManager
     */
    public function getResetProgressManager(): ResetProgressManager{
        return $this->resetProgressManager;
    }

    /**
     * @return MineCommand
     */
    public function getMainCommand(): MineCommand{
        return $this->mainCommand;
    }

    /**
     * @return CreationListener
     */
    public function getCreationListener(): CreationListener{
        return $this->creationListener;
    }

    /**
     * @return RegionBlockerListener
     */
    public function getRegionBlockerListener(): RegionBlockerListener{
        return $this->regionBlockerListener;
    }


    public static function supportsChunkSetting(): bool {
        return static::$supportsChunkSetting;
    }

    private static function detectChunkSetting(){
        if(self::$supportsChunkSetting === null) {
            $class = new \ReflectionClass(Level::class);
            $func = $class->getMethod("setChunk");
            $filename = $func->getFileName();
            $start_line = $func->getStartLine() - 1;
            $end_line = $func->getEndLine();
            $length = $end_line - $start_line;

            $source = file($filename);
            $body = implode("", array_slice($source, $start_line, $length));
            self::$supportsChunkSetting = strpos($body, 'removeEntity') !== false;
        }
    }
}<?php
namespace falkirks\minereset;


use falkirks\minereset\store\DataStore;
use falkirks\minereset\store\Reloadable;
use falkirks\minereset\store\Saveable;
use pocketmine\math\Vector3;
use pocketmine\utils\TextFormat;

class MineManager implements \ArrayAccess, \IteratorAggregate, \Countable {
    const MEMORY_TILL_CLOSE = 0;
    const FLUSH_ON_CHANGE = 1;

    /** @var MineReset  */
    private $api;
    /** @var DataStore  */
    private $store;
    /** @var  Mine[] */
    private $mines;
    private $flag;

    public function __construct(MineReset $api, DataStore $store, $flag = MineManager::FLUSH_ON_CHANGE){
        $this->api = $api;
        $this->store = $store;
        $this->flag = $flag;
        $this->mines = [];
        if($this->flag < 2){
            $this->mines = $this->loadMines();
        }
    }
    /**
     * @deprecated
     */
    protected function reloadStore(){
        if($this->flag >= 2 && $this->store instanceof Reloadable){
            $this->store->reload();
        }
    }
    protected function saveStore($force = false){
        if(($this->flag > 0 || $force) && $this->store instanceof Saveable){
            $this->store->save();
        }
    }
    protected function loadMines(): array{
        $out = [];
        foreach($this->store->getIterator() as $name => $data){
            $out[$name] = $this->mineFromData($name, $data);
        }
        return $out;
    }

    /**
     * WARNING
     * This function is for internal use only.
     */
    public function saveAll(){
        if($this->flag === 0){
            $this->store->clear();
            foreach($this->mines as $mine){
                $this->store->add($mine->getName(), $this->mineToData($mine));
            }
            $this->saveStore(true);
        }
    }
    /**
     * (PHP 5 &gt;= 5.0.0)<br/>
     * Whether a offset exists
     * @link http://php.net/manual/en/arrayaccess.offsetexists.php
     * @param mixed $offset <p>
     * An offset to check for.
     * </p>
     * @return boolean true on success or false on failure.
     * </p>
     * <p>
     * The return value will be casted to boolean if non-boolean was returned.
     */
    public function offsetExists($offset){
        return isset($this->mines[$offset]);
    }
    /**
     * (PHP 5 &gt;= 5.0.0)<br/>
     * Offset to retrieve
     * @link http://php.net/manual/en/arrayaccess.offsetget.php
     * @param mixed $offset <p>
     * The offset to retrieve.
     * </p>
     * @return mixed Can return all value types.
     */
    public function offsetGet($offset){
        return $this->mines[$offset] ?? null;
    }
    /**
     * (PHP 5 &gt;= 5.0.0)<br/>
     * Offset to set
     * @link http://php.net/manual/en/arrayaccess.offsetset.php
     * @param mixed $offset <p>
     * The offset to assign the value to.
     * </p>
     * @param mixed $value <p>
     * The value to set.
     * </p>
     * @return void
     */
    public function offsetSet($offset, $value){
        if($value instanceof Mine && $value->getName() === $offset) {

            if(isset($this->mines[$offset]) && $value !== $this->mines[$offset] && $this->mines[$offset] instanceof Mine){
                $this->mines[$offset]->destroy();
            }

            $this->mines[$offset] = $value;
            if ($this->flag === 1) {
                $this->store->add($offset, $this->mineToData($value));
                $this->saveStore();
            }
        }
        else{
            throw new \RuntimeException("Invalid \$offset for mine data.");
        }
    }
    /**
     * (PHP 5 &gt;= 5.0.0)<br/>
     * Offset to unset
     * @link http://php.net/manual/en/arrayaccess.offsetunset.php
     * @param mixed $offset <p>
     * The offset to unset.
     * </p>
     * @return void
     */
    public function offsetUnset($offset){
        if(isset($this->mines[$offset])) {
            if ($this->mines[$offset] instanceof Mine) {
                $this->mines[$offset]->destroy();
            }
            unset($this->mines[$offset]);
            if ($this->flag === 1) {
                $this->store->remove($offset);
                $this->saveStore();
            }
        }
    }
    /**
     * This method requires the key of the warp in order
     * to construct a mine object
     * @param $name
     * @param array $array
     * @return Mine
     * @throws \Exception
     */
    protected function mineFromData($name, array $array){
        if(count($array) === 9 || count($array) === 8) {
            if(!$this->getApi()->getServer()->isLevelLoaded($array[7])){
                $this->api->getLogger()->warning("A mine with the name " . TextFormat::AQUA . $name . TextFormat::RESET . " is connected to a level which is not loaded. You won't be able to use it until you load the level correctly.");
            }
            return new Mine($this,
                new Vector3(min($array[0], $array[1]), min($array[2], $array[3]), min($array[4], $array[5])),
                new Vector3(max($array[0], $array[1]), max($array[2], $array[3]), max($array[4], $array[5])),
                $array[7],
                $name,
                (is_array($array[6]) ? $array[6] : []),
                $array[8] ?? -1);
        }
        $this->api->getLogger()->critical("A mine with the name " . TextFormat::AQUA . $name . TextFormat::RESET . " is incomplete. It will be removed automatically when your server stops.");
        return null;
    }
    /**
     * In order to pass data to a DataStore
     * a key is needed. Typically one should
     * use $warp->getName()
     * @param Mine $mine
     * @return array
     */
    protected function mineToData(Mine $mine){
        return  [
            $mine->getPointA()->getX(),
            $mine->getPointB()->getX(),
            $mine->getPointA()->getY(),
            $mine->getPointB()->getY(),
            $mine->getPointA()->getZ(),
            $mine->getPointB()->getZ(),
            (count($mine->getData()) > 0 ? $mine->getData() : false),
            $mine->getLevelName(),
            $mine->getResetInterval()
        ];
    }
    /**
     * (PHP 5 &gt;= 5.0.0)<br/>
     * Retrieve an external iterator
     * @link http://php.net/manual/en/iteratoraggregate.getiterator.php
     * @return \Traversable An instance of an object implementing <b>Iterator</b> or
     * <b>Traversable</b>
     */
    public function getIterator(){
        return new \ArrayIterator($this->mines);
    }

    public function count(){
        return count($this->mines);
    }


    /**
     * Returns the current storage-mode
     * #####
     *  MEMORY_TILL_CLOSE = 0
     * Mines are loaded into memory when the server starts and are
     * held there until the server closes. When the server closes
     * they are converted back into YAML. This new YAML will
     * replace mines.yml, this means that changes are lost and
     * warps which fail to load are discarded.
     *
     *
     * FLUSH_ON_CHANGE = 1
     * Mines are loaded into memory when the server starts. Whenever a
     * mine is updated, it will be updated in the mines.yml. When the
     * server closes, the mines file is NOT overwritten.
     *
     * NO_MEMORY_STORE = 2
     * THIS IS NOT SUPPORTED
     * ####
     * @return int
     */
    public function getFlag(): int{
        return $this->flag;
    }
    /**
     * returns the current data store
     * @return DataStore
     */
    public function getStore(): DataStore{
        return $this->store;
    }
    /**
     * Injects a new DataStore for warps
     * ! This will inject your code into MineReset, potentially breaking!
     * @param DataStore $store
     */
    public function setStore(DataStore $store){
        $this->saveAll();
        $this->store = $store;
        $this->mines = $this->loadMines();
    }

    /**
     * @return MineReset
     */
    public function getApi(): MineReset{
        return $this->api;
    }

    /**
     * @return Mine[]
     */
    public function getMines(): array{
        return $this->mines;
    }
}<?php
namespace falkirks\minereset\store;

use pocketmine\utils\Config;

/**
 * Class YAMLStore
 * @package falkirks\minereset\store
 */
class YAMLStore extends AbstractStore implements Saveable, Reloadable{
    /** @var Config  */
    private $config;

    /**
     * YAMLStore constructor.
     * @param Config $config
     */
    public function __construct(Config $config){
        $this->config = $config;
    }

    /**
     * Adds a new mine and returns the old one
     * @param $name
     * @param $warp
     * @return bool|mixed
     */
    public function add($name, $mine){
        $past = $this->config->get($name, null);
        $this->config->set($name, $mine);
        $this->config->save();
        return $past;
    }

    /**
     * Gets mine with $name
     * @param $name
     * @return bool|mixed
     */
    public function get($name){
        return $this->config->get($name, null);
    }

    /**
     * Removes a mine with $name and returns it
     * @param $name
     * @return bool|mixed
     */
    public function remove($name){
        $past = $this->config->get($name, null);
        $this->config->remove($name);
        $this->config->save();
        return $past;
    }

    /**
     * Clears all mines
     */
    public function clear(){
        $this->config->setAll([]);
        $this->config->save();
    }

    /**
     *  Reloads the mines from YAML
     */
    public function reload(){
        $this->config->reload();
    }
    /**
     * Returns something which can be used to iterate
     * over the store.
     * @return mixed
     */
    public function getIterator(){
        return $this->config->getAll();
    }

    /**
     * Saves mines to file
     */
    public function save(){
        $this->config->save();
    }
}<?php
namespace falkirks\minereset\store;

/**
 * This is extracted from SimpleWarp and redistributed under the same license
 * as Mine Reset.
 *
 * Interface AbstractStore
 * @package falkirks\minereset\store
 */
abstract class AbstractStore implements DataStore{
    public function addAll($mines){
        foreach($mines as $name => $mine){
            $this->add($name, $mine);
        }
    }
    public function removeAll($mines){
        foreach($mines as $mine){
            $this->remove($mine);
        }
    }
    public function exists($name): bool{
        return $this->get($name) !== null;
    }
}<?php
namespace falkirks\minereset\store;

/**
 * This interface deals with the storage of arbitrary mine
 * data in a key-value store.
 *
 * This is extracted from SimpleWarp and redistributed under the same license
 * as Mine Reset.
 *
 * Interface DataStore
 * @package falkirks\minereset\store
 */
interface DataStore {
    public function addAll($mines);
    public function removeAll($mines);
    public function exists($name) : bool ;
    /**
     * This method takes a $name string and a $warp array and
     * returns the previous value that occupied $name or null.
     * @param $name
     * @param $mine
     * @return mixed
     */
    public function add($name, $mine);
    /**
     * @param $name
     * @return mixed
     */
    public function get($name);
    public function remove($name);
    public function clear();
    /**
     * Returns something which can be used to iterate
     * over the store.
     * @return mixed
     */
    public function getIterator();
}<?php
/**
 * Created by PhpStorm.
 * User: noahheyl
 * Date: 2017-04-15
 * Time: 8:44 AM
 */

namespace falkirks\minereset\store;


interface Saveable{
    public function save();
}<?php
namespace falkirks\minereset\store;


interface Reloadable{
    public function reload();
}<?php
namespace falkirks\minereset;


use pocketmine\command\CommandSender;

class ResetProgressManager{
    /** @var  MineReset */
    private $api;

    /** @var  array */
    private $subscriptions;

    /**
     * ResetProgressManager constructor.
     * @param MineReset $api
     */
    public function __construct(MineReset $api){
        $this->api = $api;
        $this->subscriptions = [];
    }


    public function notifyProgress(string $progress, string $mineName){
        if(isset($this->subscriptions[$mineName])){
            foreach ($this->subscriptions[$mineName] as $sender){
                $sender->sendMessage("RESET {$mineName}: {$progress}");
            }
        }
    }

    public function notifyComplete(string $mineName){
        if(isset($this->getApi()->getMineManager()[$mineName])){
            $this->getApi()->getMineManager()[$mineName]->doneReset();
        }
        if(isset($this->subscriptions[$mineName])){
            foreach ($this->subscriptions[$mineName] as $sender){
                $sender->sendMessage("Reset of {$mineName} has completed.");
            }
            unset($this->subscriptions[$mineName]);
        }
    }

    public function addObserver(string $mineName, CommandSender $sender){
        if(!isset($this->subscriptions[$mineName])){
            $this->subscriptions[$mineName] = [];
        }
        $this->subscriptions[$mineName][] = $sender;
    }

    /**
     * @return MineReset
     */
    public function getApi(): MineReset{
        return $this->api;
    }


}<?php
namespace falkirks\minereset\listener;


use falkirks\minereset\Mine;
use falkirks\minereset\MineReset;
use pocketmine\event\block\BlockBreakEvent;
use pocketmine\event\block\BlockPlaceEvent;
use pocketmine\event\Listener;
use pocketmine\event\player\PlayerMoveEvent;
use pocketmine\level\Position;
use pocketmine\utils\TextFormat;

class RegionBlockerListener implements Listener {
    /** @var  MineReset */
    private $api;

    /**
     * RegionBlockerListener constructor.
     * @param MineReset $api
     */
    public function __construct(MineReset $api){
        $this->api = $api;
    }


    public function clearMine(string $mineName){
        /** @var Mine $mine */
        $mine = $this->getApi()->getMineManager()[$mineName];
        if($mine !== null){
            foreach ($this->getApi()->getServer()->getOnlinePlayers() as $player){
                if($mine->isPointInside($player->getPosition())){
                    $player->teleport($player->getLevel()->getSafeSpawn($player->getPosition()));
                    $player->sendMessage("You have teleported to escape a resetting mine.");
                }
            }
        }
    }

    /**
     * @priority HIGH
     *
     * @param BlockPlaceEvent $event
     */
    public function onBlockPlace(BlockPlaceEvent $event){

        $mine = $this->getResettingMineAtPosition($event->getBlock());
        if($mine != null){
            $event->getPlayer()->sendMessage(TextFormat::RED . "A mine is currently resetting in this area. You may not place blocks." . TextFormat::RESET);
            $event->setCancelled();
        }
    }

    /**
     * @priority HIGH
     *
     * @param BlockBreakEvent $event
     */
    public function onBlockDestroy(BlockBreakEvent $event){

        $mine = $this->getResettingMineAtPosition($event->getBlock());
        if($mine != null){
            $event->getPlayer()->sendMessage(TextFormat::RED . "A mine is currently resetting in this area. You may not break blocks." . TextFormat::RESET);
            $event->setCancelled();
        }
    }

    private function getResettingMineAtPosition(Position $position){
        foreach ($this->getApi()->getMineManager() as $mine) {
            if($mine->isResetting() && $mine->isPointInside($position)){
                return $mine;
            }
        }
        return null;
    }

    /**
     * @return MineReset
     */
    public function getApi(): MineReset{
        return $this->api;
    }


}<?php
namespace falkirks\minereset\listener;


use falkirks\minereset\MineReset;
use pocketmine\event\Listener;
use pocketmine\event\player\PlayerInteractEvent;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class CreationListener implements Listener {
    /** @var  MineReset */
    private $api;

    /** @var  MineCreationSession[] */
    private $sessions;


    /**
     * CreationListener constructor.
     * @param MineReset $api
     */
    public function __construct(MineReset $api){
        $this->api = $api;
        $this->sessions = [];
    }

    /**
     * @priority LOW
     * @ignoreCancelled true
     *
     * @param PlayerInteractEvent $event
     */
    public function onBlockTap(PlayerInteractEvent $event){
        $session = $this->getPlayerSession($event->getPlayer());

        if($session !== null){
            if($session->getLevel() === null || $session->getLevel()->getId() === $event->getPlayer()->getLevel()->getId()) {
                $session->setNextPoint($event->getBlock());
                $session->setLevel($event->getPlayer()->getPosition()->getLevel());

                if($session->canGenerate()){
                    $mine = $session->generate($this->getApi()->getMineManager());
                    $event->getPlayer()->sendMessage("You have created a mine called " . $mine->getName() . ".");
                    $event->getPlayer()->sendMessage("You can set it using /mine set " . $mine->getName() . " <data>");
                    unset($this->sessions[array_search($session, $this->sessions)]);
                }
                else{
                    $event->getPlayer()->sendMessage("You have set position A. Tap another block to set position B.");
                }
            }
            else{
                $event->getPlayer()->sendMessage(TextFormat::RED . "Failed to create mine due to level switch". TextFormat::RESET);
                unset($this->sessions[array_search($session, $this->sessions)]);
            }
        }
    }

    /**
     * @return MineReset
     */
    public function getApi(): MineReset{
        return $this->api;
    }

    public function playerHasSession(Player $player): bool {
        foreach ($this->sessions as $session){
            if($session->getPlayer()->getName() === $player->getName()){
                return true;
            }
        }
        return false;
    }

    public function getPlayerSession(Player $player){
        foreach ($this->sessions as $session){
            if($session->getPlayer()->getName() === $player->getName()){
                return $session;
            }
        }
        return null;
    }


    public function addSession(MineCreationSession $session): bool {
        if(!$this->playerHasSession($session->getPlayer())) {
            $this->sessions[] = $session;
            return true;
        }
        return false;
    }


}<?php

namespace falkirks\minereset\listener;


use falkirks\minereset\Mine;
use falkirks\minereset\MineManager;
use pocketmine\level\Level;
use pocketmine\math\Vector3;
use pocketmine\Player;

class MineCreationSession{
    /** @var  string */
    private $name;
    /** @var  Player */
    private $player;
    /** @var Vector3 */
    private $pointA;
    /** @var Vector3 */
    private $pointB;
    /** @var  Level */
    private $level;

    /**
     * MineCreationSession constructor.
     * @param string $name
     * @param Player $player
     */
    public function __construct(string $name, Player $player){
        $this->name = $name;
        $this->player = $player;
        $this->pointA = null;
        $this->pointB = null;
        $this->level = null;
    }

    /**
     * @return string
     */
    public function getName(): string{
        return $this->name;
    }

    /**
     * @return Player
     */
    public function getPlayer(): Player{
        return $this->player;
    }

    /**
     * @param Player $player
     */
    public function setPlayer(Player $player){
        $this->player = $player;
    }

    /**
     * @return Vector3 | null
     */
    public function getPointA(){
        return $this->pointA;
    }

    /**
     * @param Vector3 $pointA
     */
    public function setPointA(Vector3 $pointA){
        $this->pointA = $pointA;
    }

    /**
     * @return Vector3 | null
     */
    public function getPointB(){
        return $this->pointB;
    }

    /**
     * @param Vector3 $pointB
     */
    public function setPointB(Vector3 $pointB){
        $this->pointB = $pointB;
    }

    /**
     * @return Level | null
     */
    public function getLevel(){
        return $this->level;
    }

    /**
     * @param Level $level
     */
    public function setLevel(Level $level){
        $this->level = $level;
    }

    public function setNextPoint(Vector3 $point){
        if($this->pointA === null){
            $this->setPointA($point);
        }
        else if($this->pointB === null){
            $this->setPointB($point);
        }
    }

    public function canGenerate() : bool {
        return $this->pointA !== null && $this->pointB !== null && $this->level !== null;
    }

    public function generate(MineManager $owner): Mine{
        if($this->canGenerate()){
            $mine = new Mine($owner,
                new Vector3(min($this->pointA->getFloorX(), $this->pointB->getFloorX()), min($this->pointA->getFloorY(), $this->pointB->getFloorY()), min($this->pointA->getFloorZ(), $this->pointB->getFloorZ())),
                new Vector3(max($this->pointA->getFloorX(), $this->pointB->getFloorX()), max($this->pointA->getFloorY(), $this->pointB->getFloorY()), max($this->pointA->getFloorZ(), $this->pointB->getFloorZ())),
                $this->level->getName(),
                $this->name);
            $owner[$this->name] = $mine;
            return $mine;
        }
        else{
            throw new \InvalidStateException();
        }
    }

}<?php

namespace falkirks\minereset\command;


use falkirks\minereset\MineReset;
use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\command\PluginIdentifiableCommand;
use pocketmine\plugin\Plugin;

class MineCommand extends Command implements PluginIdentifiableCommand {
    /** @var MineReset  */
    protected $api;
    /** @var  SubCommand[] */
    protected $subCommands;
    public function __construct(MineReset $api){
        parent::__construct("mine", "Mine reset command", "/mine <create|set|list|reset|reset-all|destroy> <name> [parameters]");
        $this->api = $api;
        $this->subCommands = [];
    }
    /**
     * @param CommandSender $sender
     * @param string $commandLabel
     * @param string[] $args
     *
     * @return mixed
     */
    public function execute(CommandSender $sender, $commandLabel, array $args){
        if(count($args) > 0 && array_key_exists($args[0], $this->subCommands)){
            return $this->subCommands[array_shift($args)]->execute($sender, $commandLabel, $args);
        }
        else{
            $sender->sendMessage($this->getUsage());
            return null;
        }
    }

    /**
     * @return \pocketmine\plugin\Plugin
     */
    public function getPlugin(): Plugin{
        return $this->api;
    }

    public function registerSubCommand(string $name, SubCommand $command, $aliases = []){
        $this->subCommands[$name] = $command;

        foreach ($aliases as $alias){
            if(!isset($this->subCommands[$alias])){
                $this->registerSubCommand($alias, $command);
            }
        }
    }
}<?php

namespace falkirks\minereset\command;


use falkirks\minereset\task\AboutPullTask;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class AboutCommand extends SubCommand{
    public function execute(CommandSender $sender, $commandLabel, array $args){
        if($sender->hasPermission("minereset.command.about")) {
            $this->getApi()->getServer()->getScheduler()->scheduleAsyncTask(new AboutPullTask($sender));
        }
        else{
            $sender->sendMessage(TextFormat::RED . "You do not have permission to run this command." . TextFormat::RESET);
        }
    }
}<?php
namespace falkirks\minereset\command;


use falkirks\minereset\MineReset;
use pocketmine\command\CommandSender;

abstract class SubCommand{
    /** @var  MineReset */
    private $api;

    /**
     * SubCommand constructor.
     * @param MineReset $api
     */
    public function __construct(MineReset $api){
        $this->api = $api;
    }


    abstract public function execute(CommandSender $sender, $commandLabel, array $args);

    /**
     * @return MineReset
     */
    public function getApi(): MineReset{
        return $this->api;
    }
}<?php
namespace falkirks\minereset\command;


use falkirks\minereset\Mine;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class ListCommand extends SubCommand{
    public function execute(CommandSender $sender, $commandLabel, array $args){
        if($sender->hasPermission("minereset.command.list")) {
            foreach ($this->getApi()->getMineManager() as $mine) {
                if ($mine instanceof Mine) {
                    $sender->sendMessage($mine->getName());
                }
            }
        }
        else{
            $sender->sendMessage(TextFormat::RED . "You do not have permission to run this command." . TextFormat::RESET);
        }
    }
}<?php
namespace falkirks\minereset\command;


use falkirks\minereset\listener\MineCreationSession;
use falkirks\minereset\Mine;
use pocketmine\command\CommandSender;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class CreateCommand extends SubCommand{


    public function execute(CommandSender $sender, $commandLabel, array $args){
        if($sender->hasPermission("minereset.command.create")) {
            if ($sender instanceof Player) {
                if (isset($args[0])) {
                    if (!$this->getApi()->getCreationListener()->playerHasSession($sender)) {
                        if (!isset($this->getApi()->getMineManager()[$args[0]])) {
                            $this->getApi()->getCreationListener()->addSession(new MineCreationSession($args[0], $sender));
                            $sender->sendMessage("Tap a block to set position A.");
                        } else {
                            $sender->sendMessage("That mine already exists. You must run \"/mine destroy {$args[0]}\" before creating a new one.");
                        }
                    } else {
                        $sender->sendMessage("Hold up! You are already in the process of creating a mine. You need to finish that first.");
                    }

                } else {
                    $sender->sendMessage("Usage: /mine create <name>");
                }
            } else {
                $sender->sendMessage(TextFormat::RED . "This command can only be run in-game." . TextFormat::RESET);
            }
        }
        else{
            $sender->sendMessage(TextFormat::RED . "You do not have permission to run this command." . TextFormat::RESET);
        }
    }
}<?php
namespace falkirks\minereset\command;


use falkirks\minereset\Mine;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class SetCommand extends SubCommand{
    public function execute(CommandSender $sender, $commandLabel, array $args){
        if($sender->hasPermission("minereset.command.set")) {
            if (isset($args[0])) {
                if (isset($this->getApi()->getMineManager()[$args[0]])) {
                    if (isset($args[2])) {
                        $sets = array_slice($args, 1);
                        $save = [];
                        if (count($sets) % 2 === 0) {
                            $total = 0;
                            foreach ($sets as $key => $item) {
                                if (strpos($item, "%")) {
                                    $sender->sendMessage(TextFormat::RED . "Your format string looks incorrect." . TextFormat::RESET);
                                    return;
                                }
                                if ($key & 1) {
                                    $total += $item;
                                    if (isset($save[$sets[$key - 1]])) {
                                        $save[$sets[$key - 1]] += $item;
                                    }
                                    else {
                                        $save[$sets[$key - 1]] = $item;
                                    }
                                }
                            }
                            if($total === 100) {
                                $this->getApi()->getMineManager()[$args[0]]->setData($save);
                                $sender->sendMessage(TextFormat::GREEN . "Mine has been setted. Use /mine reset {$args[0]} to see your changes.");
                            }
                            else{
                                $sender->sendMessage(TextFormat::RED . "The percents on your mine must add to 100, but they add to {$total}." . TextFormat::RESET);
                            }
                        }
                        else {
                            $sender->sendMessage(TextFormat::RED . "Your format string looks incorrect." . TextFormat::RESET);
                        }
                    }
                    else {
                        $sender->sendMessage("You must provide at least one block with a chance value.");
                    }
                }
                else {
                    $sender->sendMessage("{$args[0]} is not a valid mine.");
                }
            }
            else {
                $sender->sendMessage("Usage: /mine set <name> <data>");
            }
        }
        else{
            $sender->sendMessage(TextFormat::RED . "You do not have permission to run this command." . TextFormat::RESET);
        }
    }
}<?php
namespace falkirks\minereset\command;


use falkirks\minereset\Mine;
use falkirks\minereset\MineReset;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class DestroyCommand extends SubCommand{

    const DESTROY_STRINGS = [
        "a",
        "b",
        "c",
        "5",
        "7",
        "-f",
        "DEATH",
        "yes",
        "15",
        "y"
    ];

    private $offset;
    private $senders;

    public function __construct(MineReset $mineReset){
        parent::__construct($mineReset);
        $this->offset = 0;
        $this->senders = [];
    }


    public function execute(CommandSender $sender, $commandLabel, array $args){
        if($sender->hasPermission("minereset.command.destroy")) {
            if (isset($args[0])) {
                if (isset($this->getApi()->getMineManager()[$args[0]])) {
                    if (isset($args[1]) && isset($this->senders[$sender->getName()]) && $this->senders[$sender->getName()] === $args[1]) {
                        unset($this->getApi()->getMineManager()[$args[0]]);
                        unset($this->senders[$sender->getName()]);
                        $sender->sendMessage("{$args[0]} has been destroyed.");
                    } else {
                        $str = DestroyCommand::DESTROY_STRINGS[$this->offset];
                        $sender->sendMessage("Run: " . TextFormat::AQUA . "/mine destroy {$args[0]} $str" . TextFormat::RESET);
                        $sender->sendMessage("To destroy mines faster, you can edit the config file directly.");
                        $this->senders[$sender->getName()] = $str;

                        if ($this->offset === count(DestroyCommand::DESTROY_STRINGS) - 1) {
                            $this->offset = -1;
                        }

                        $this->offset++;
                    }
                } else {
                    $sender->sendMessage("{$args[0]} is not a valid mine.");
                }
            } else {
                $sender->sendMessage("Usage: /mine destroy <name>");
            }
        }
        else{
            $sender->sendMessage(TextFormat::RED . "You do not have permission to run this command." . TextFormat::RESET);
        }
    }
}<?php
namespace falkirks\minereset\command;


use falkirks\minereset\Mine;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class ResetCommand extends SubCommand{
    public function execute(CommandSender $sender, $commandLabel, array $args){
        if($sender->hasPermission("minereset.command.reset")) {
            if (isset($args[0])) {
                if (isset($this->getApi()->getMineManager()[$args[0]])) {
                    if ($this->getApi()->getMineManager()[$args[0]]->reset()) {
                        $sender->sendMessage("Queued reset for {$args[0]}.");
                        $this->getApi()->getResetProgressManager()->addObserver($args[0], $sender);
                    }
                    else {
                        $sender->sendMessage("Could not queue reset for {$args[0]}.");
                    }
                }
                else {
                    $sender->sendMessage("{$args[0]} is not a valid mine.");
                }
            }
            else {
                $sender->sendMessage("Usage: /mine reset <name>");
            }
        }
        else{
            $sender->sendMessage(TextFormat::RED . "You do not have permission to run this command." . TextFormat::RESET);
        }
    }
}<?php
namespace falkirks\minereset\command;


use falkirks\minereset\Mine;
use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;

class ResetAllCommand extends SubCommand{
    public function execute(CommandSender $sender, $commandLabel, array $args){
        if($sender->hasPermission("minereset.command.resetall")) {
            $success = 0;
            foreach ($this->getApi()->getMineManager() as $mine) {
                if ($mine instanceof Mine) {
                    if ($mine->reset()) {
                        $success++;
                        $this->getApi()->getResetProgressManager()->addObserver($mine->getName(), $sender);
                    }
                }
            }
            $count = count($this->getApi()->getMineManager());
            $sender->sendMessage("Queued reset for {$success}/{$count} mines.");
        }
        else{
            $sender->sendMessage(TextFormat::RED . "You do not have permission to run this command." . TextFormat::RESET);
        }
    }
}